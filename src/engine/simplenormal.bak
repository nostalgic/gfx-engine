const shader = `
            precision highp float;
            out vec4 FragColor;
            in vec2 vUv;

            ${COMMON_UNIFORMS}
            ${MATH_UTILS}
            ${NOISE_LIB}
            ${DOMAIN_FX}
            ${FOG_FX}
            ${activeSDF}
            ${mapFunction}

            vec3 getNormal(vec3 p, float t) {
                float e = 0.001 * t;
                vec2 h = vec2(e, 0);
                return normalize(vec3(
                    map(p+h.xyy, 0, t) - map(p-h.xyy, 0, t),
                    map(p+h.yxy, 0, t) - map(p-h.yxy, 0, t),
                    map(p+h.yyx, 0, t) - map(p-h.yyx, 0, t)
                ));
            }

            void mainImage(out vec4 fragColor, in vec2 fragCoord) {
                vec2 uv = fragCoord / u_resolution.xy;
                vec2 rayUV = texture(u_uv_feedback, uv).rg; 

                float camDist = u_camera_distance;
                vec3 ro = vec3(
                    camDist * sin(u_camera_phi) * sin(-u_camera_theta),
                    camDist * cos(u_camera_phi),
                    camDist * sin(u_camera_phi) * cos(-u_camera_theta)
                );
                vec3 ta = vec3(0.0);
                vec3 ww = normalize(ta - ro);
                vec3 uu = normalize(cross(ww, vec3(0,1,0)));
                vec3 vv = normalize(cross(uu, ww));
                vec3 rd = normalize(rayUV.x * uu + rayUV.y * vv + 1.5 * ww);

                float t = 0.0;
                float d = 0.0;
                int i = 0;
                for(i=0; i<128; i++) {
                    vec3 p = ro + rd * t;
                    d = map(p, i, t);
                    if(d < 0.001 || t > 40.0) break;
                    t += d;
                }

                vec3 col = vec3(0.0);
                if(t < 40.0) {
                    vec3 p = ro + rd * t;
                    vec3 n = getNormal(p, t);
                    float diff = max(dot(n, normalize(vec3(u_light_pos_x, u_light_pos_y, u_light_pos_z))), 0.0);
                    col = palette(length(p)*u_color_intensity + u_time*0.1);
                    col *= (diff * u_diffuse_strength + u_ambient_strength);
                    col += pow(max(dot(reflect(-normalize(vec3(u_light_pos_x, u_light_pos_y, u_light_pos_z)), n), -rd), 0.0), u_specular_power) * u_specular_strength;
                } else {
                    col = palette(fragCoord.y/u_resolution.y * 0.2) * u_background_brightness * 0.1;
                }

                fragColor = vec4(col, 1.0);
            }

            void main() {
                mainImage(FragColor, vUv * u_resolution);
            }
        `;